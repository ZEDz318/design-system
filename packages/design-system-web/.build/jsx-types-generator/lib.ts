import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
interface Decomposed {
  import: string[];
  nsComponents: string[];
  expInterfaces: string[];
  global: string[];
  tagNameMap: string[];
  localjsx: string[];
  localIntrinsic: string[];
  intrinsic: string[];
}

// function to read file to string
export function readFile(file: string): string {
  const sourcePath = join(__dirname, file);
  return readFileSync(sourcePath).toString();
}

// function to write file
export function writeFile(path: string, content: string) {
  const targetPath = join(__dirname, path);
  writeFileSync(targetPath, content);
}

/**
 * Decompose a components.d.ts file generated by @stencil/core
 * into blocks.
 * @param input
 * @returns
 */
export function decompose(input: string): Decomposed {
  const res: Decomposed = {
    import: [],
    nsComponents: [],
    expInterfaces: [],
    global: [],
    tagNameMap: [],
    localjsx: [],
    localIntrinsic: [],
    intrinsic: [],
  };
  let section = 'init';

  // function to extract imports
  const lines = input.split('\n');
  lines.forEach(line => {
    switch (section) {
      case 'init':
        if (line.startsWith('import {')) {
          res.import.push(line);
          section = 'import';
        }
        break;
      case 'import':
        if (!line.startsWith('export namespace Components {')) {
          res.import.push(line);
        } else {
          section = 'nsComponents';
        }
        break;
      case 'nsComponents':
        if (line !== '}') {
          res.nsComponents.push(line);
        } else {
          section = 'expInterfaces';
        }
        break;
      case 'expInterfaces':
        if (line !== 'declare global {') {
          res.expInterfaces.push(line);
        } else {
          section = 'global';
        }
        break;
      case 'global':
        if (!line.endsWith('interface HTMLElementTagNameMap {')) {
          res.global.push(line);
        } else {
          section = 'tagNameMap';
        }
        break;
      case 'tagNameMap':
        if (!line.endsWith('}')) {
          res.tagNameMap.push(line);
        } else {
          section = 'tagNameMapSkip';
        }
        break;
      case 'tagNameMapSkip':
        if (line === 'declare namespace LocalJSX {') {
          section = 'localjsx';
        }
        break;
      case 'localjsx':
        if (!line.endsWith('interface IntrinsicElements {')) {
          res.localjsx.push(line);
        } else {
          section = 'localIntrinsic';
        }
        break;
      case 'localIntrinsic':
        if (!line.endsWith('}')) {
          res.localIntrinsic.push(line);
        } else {
          section = 'export';
        }
        break;
      case 'export':
        // skip everything until intrinsic elements
        if (line.endsWith('interface IntrinsicElements {')) {
          section = 'intrinsic';
        }
        break;
      case 'intrinsic':
        if (!line.endsWith('}')) {
          res.intrinsic.push(line);
        } else {
          section = 'end';
        }
        break;
      default:
        break;
    }
  });
  return res;
}

/**
 * Recompose a Decomposed into a components.d.ts file
 * as if it was generated by @stencil/core
 * @param decomposed
 * @returns
 */
export function recompose(decomposed: Decomposed) {
  return `${decomposed.import.join('\n')}
export namespace Components {
${decomposed.nsComponents.join('\n')}
}
${decomposed.expInterfaces.join('\n')}
declare global {
${decomposed.global.join('\n')}
  interface HTMLElementTagNameMap {
    ${decomposed.tagNameMap.join('\n')}
  }
}
declare namespace LocalJSX {
  ${decomposed.localjsx.join('\n')}
  interface IntrinsicElements {
    ${decomposed.localIntrinsic.join('\n')}
  }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
          ${decomposed.intrinsic.join('\n')}
        }
    }
}
`;
}

/**
 * Combine Decomposed array to one.
 * @param decomposedArr
 * @returns
 */
export function mergeDecomposed(decomposedArr: Decomposed[]) {
  const merged: Decomposed = {
    import: [],
    nsComponents: [],
    expInterfaces: [],
    global: [],
    tagNameMap: [],
    localjsx: [],
    localIntrinsic: [],
    intrinsic: [],
  };
  for (const decomposed of decomposedArr) {
    for (const key in decomposed) {
      if (Object.prototype.hasOwnProperty.call(decomposed, key)) decomposed;
      const strings = decomposed[key];
      merged[key] = [...merged[key], ...strings];
    }
  }
  return merged;
}

/**
 * Cleanup imports
 * @param lines
 * @returns
 */
export function cleanupImports(lines: string[]) {
  // remove problematic lines
  const res = lines.filter(line => {
    switch (line) {
      case 'import { HTMLStencilElement, JSXBase } from "@ionic/core";':
      case 'import { PickerColumnItem } from "@ionic/core";':
      case 'import { PickerInternalChangeEventDetail } from "@ionic/core";':
      case 'import { Color } from "@ionic/core";':
      case 'export { Color } from "@ionic/core";':
        return false;
      default:
        return true;
    }
  });
  // add missing lines
  res.push(`import { PickerColumnItem } from '@ionic/core/dist/types/components/picker-column-internal/picker-column-internal-interfaces';`);
  res.push(`import { PickerInternalChangeEventDetail } from '@ionic/core/dist/types/components/picker-internal/picker-internal-interfaces';`);
  return res;
}

/**
 * Create a jsx definition to make the webcomponents (!) accepted by react.
 * This is not a replacement of the files generated by react output target.
 * @param sourceFileName
 * @param targetFileName
 */
export function createJsxForReact(sourceFileName, targetFileName) {
  const sourceFile = readFile('../../src/' + sourceFileName);

  // this typings are not perfect, but it serves as a hack.
  const targetFile = sourceFile
    .replace(
      'declare module "@stencil/core"',
      `
    export interface StyleReactProps {
      class?: string;
      style?: { [key: string]: any };
    }
    export type StencilReactExternalProps<PropType, ElementType> = PropType &
      Omit<React.HTMLAttributes<ElementType>, 'style', 'class'> &
      StyleReactProps;

    declare global`,
    )
    .replace(/LocalJSX\.(\w+)\b/g, 'StencilReactExternalProps<LocalJSX.$1, JSXBase.HTMLAttributes<HTML$1Element>>')
    // .replace(/LocalJSX\.(\w+)\b/g, 'React.DetailedHTMLProps<React.HTMLAttributes<HTMLElement> & LocalJSX.$1, HTML$1Element>')
    .replace(/\s& JSXBase.HTMLAttributes<.*/g, ';');

  writeFile('../../src/' + targetFileName, targetFile);
}
